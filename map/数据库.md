# 数据库

## 一、事务

### ACID

- A 原子性：事务的最小执行单位，不允许分割 要么全部成功 要么完成不执行
- C 一致性：事务执行前后 数据保持一致 多个事务对同一个数据的执行结果是相同的
- I 隔离性：各个事务之间相互不影响。锁实现
- D 持久性：事务一旦被提交 对数据的改变是永久的 即便故障也能恢复

### 隔离级别

- 读未提交：最低隔离级别 可能出现所有并发问题 脏读 幻读 不可重复读
  - 原理：直接返回数据库值
- 读已提交：避免脏读
  - 原理：视图，MVCC
- 可重复读：避免脏读和不可重复读
  - 原理：视图，MVCC
- 串行化：最高隔离级别
  - 原理：加锁

### 并发带来的问题

- 脏读：A事务修改数据 B事务读到修改后的数据 A事务回滚  B读到脏数据
- 不可重复读：A事务开始 B事务读数据  A事务修改数据 B事务再读数据 两次读到的数据不一致
- 幻读：A事务开始 B事务读数据  A事务增加数据 B事务再读数据 两次读到的数据不一致 第二次数据比第一次多	

### 实现方式

- 锁
  - 行锁
  - 间隙锁：https://time.geekbang.org/column/article/75173
  - 保证隔离性
- NextKeyLock
  - 行锁+间隙锁
  - 解决幻读问题
- redo log
  - 保证原子性 持久性
  - 恢复提交事务修改的页操作
- undo log
  - 保证一致性
  - 回滚记录到某个特定版本

### MVCC实现原理

MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

CRUD过程

- select
  				只查找事务版本小于等于当前版本的数据行
  				行的删除版本要么未定义，要么大于当前事务版本。确保读到的行，都是未删除的
- insert
  				插入新行 保存当前事务版本号作为行的创建版本
- delete
  				修改当前行的删除版本号为当前事务版本
- update
  				新建一条记录 当前事务版本作为创建版本，同时更新旧行的删除版本号

## 二、索引

### 聚集索引

主键索引 叶子节点存完整数据

数据存储于索引聚集在一起 找到索引也就找到了数据

主键长度越小 普通索引的叶子节点就越小 普通索引空间越小

### 非聚集索引

叶子节点存储主键而不是地址 查询时需要回表

### 索引原则

- 适合索引的列是出现在where中的列
- 基数较小的字段 区分度不够 没有必要建索引
- 使用长字符串做索引 应该指定索引长度
- 不需要过度索引
- 创建原则
  			最左匹配原则
  			频繁查询的字段才建索引
  			更新频繁的字段不适合做索引
  			不能有效区分的字段不能做索引 比如 性别
  			尽量扩展 不是新建索引
  			大对象列不建索引

### 覆盖索引

需要查询的列都在索引里 可以直接根据索引返回数据。  索引叶子节点存储的是索引数据 + 主键

### SQL语句执行过程

- 客户端
- Server层
  			连接器
  			查询缓存
  			分析器
  			优化器
  			执行器
- 存储引擎

### 索引类型

- 主键索引
- 普通索引
- 唯一索引
- 全文索引
- 空间索引
- 前缀索引

### 实现

B+树

- 所有数据放叶子节点上
- 叶子节点按照关键码从小到大排序
- B+树的非叶子结点只包含导航信息，不包含实际的值

B+树优势

- 磁盘读写代价低
- 查询效率更加稳定
- 有利于对数据库的扫描

### 索引不生效原因？

- 在索引字段上进行运算
- 多个索引字段进行运算
- 隐式转换
- like 没有使用最左匹配
- 使用了OR
- GroupBy
- OrderBy

## 三、分库分表

## 四、其他

### 自增ID用完之后会发生什么?

- rowId：返回 0，原来数据被覆盖 开始循环
- 自定义id：返回原来的值 插入时主键冲突

### NULL值支持唯一索引么？

### 一条SQL在MySQL执行过程

### 高性能优化建议

### 死锁处理

- 超时等待
- 死锁检测 释放

### 性能优化

- 限定数据查询范围
- 连接池
  - 大小设置
- 读写分离
- 分库分表

### InnoDB四大特性

- 插入缓冲
- 二次写
- 自适应哈希索引
- 预读

### B+树

- 定义&原理
- Why
- 与B数的区别

### Explain 结果描述

- type
- extra

### OLAP

- tidb
- clickhouse
- adb

### 主键生成算法

- 自增
- UUID
- redis生成id
- snowflake
  			描述
  			时钟回拨问题
- 美团Leaf

### 热点行更新

- 关闭死锁检测
- 控制并发读 server层限流
- 一行拆多行

### 日志

- redo log：innoDB 层
- binlog：server 层
  - 组成
    				内存
    				临时文件
    				binlog文件
  - 持久化机制
    				sync_binlog = 0 写cache 不刷盘
    				sync_binlog = 1 写cache 刷盘
    				sync_binlog= N  写cache N次之后刷盘

### 查询慢可能原因

- 等待资源
  			等待表锁
  			等待事务执行完成
  			发生死锁
  			等待flush
  			等待连接
  			CPU利用率太高
- 查询本身就慢
  			不走索引
  			数据量大
  			读的字段有更新 隔离级别

## 五、高可用

- 数据不丢
  		binlog持久化机制
- 主备一致性
  		binlog格式
  			statement 导致主备不一致
  			row 占用空间多 方便数据恢复
  			mix

## 六、大表优化

- 限定数据范围
- 读写分离
- 垂直分区
- 水平分区

## 七、锁

- 共享锁
  		读锁
  		不阻塞 多个用户可以同一时刻读取资源 不相互影响
- 排它锁
  		写锁
  		写操作阻塞其他读锁和写锁 防止其他用户读写正在写入的资源
- 表锁
- 行锁：容易出现死锁  发生冲突概率低  并发高 InnoDb支持行锁  依赖索引实现

## 八、JOIN

- 小表(过滤结果少)做驱动表
- 是否能够使用到被驱动表的索引
  		Index Nested-Loop Join
  		Block Nested-Loop Join
  			buffer size 足够大 一样
  			buffer size不够大 使用小表

## 九、索引高度计算

- InnoDB最小存储单位是页
  		16K
  		存放数据
  		存放键值+指针
  		叶子节点存放数据 非叶子节点存放键值+指针
- B+树高度&数据量
  - 2
    			第1层存储指针数：16K/(8+6)=1170
    			第2层存储数据数：16K/1K=16
    			总量 1170*16=1.8W
  - 3
    			第1层：1170
    			第2层：1170
    			第3层：16
    			总量 1170\*1170\*16=2200W

